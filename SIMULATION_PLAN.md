# Project Simulation Plan

## 1. Goal & Objective

The primary objective of this simulation phase is to **validate the end-to-end logical pipeline of the trading framework before integrating with live exchange APIs.**

By using controlled, mock data, we can ensure that the core decision-making process—from sentiment analysis to signal generation to execution—works as intended. This phase decouples the system's logic from the complexities of real-world data feeds and exchange connectivity, allowing for rapid, focused development and testing.

## 2. Core Principles

-   **Simplicity**: The simulation is not a backtest. Its purpose is to verify logic, not to prove profitability. Components should be as simple as possible while still serving their function in the pipeline.
-   **Modularity**: Each simulated component (e.g., the mock data source, the simple sentiment engine) should be easily replaceable with its real-world counterpart in the future without requiring major refactoring.
-   **Visibility**: The output of each step in the simulation must be clearly logged to the console and visible on the Streamlit dashboard. We need to see *why* the system is making the decisions it is.

## 3. Simulation Workflow

A single "tick" or cycle of the simulation will follow this sequence:

1.  **Generate Data**: The `Mock Data Source` creates a new data point (e.g., a Fear & Greed value and a new price for an asset).
2.  **Determine Regime**: The `Basic Sentiment Engine` reads the mock data and determines the current market regime (e.g., "Fearful", "Greedy").
3.  **Generate Signal**: The `Basic Strategy Engine` evaluates the current regime and mock price data. If its conditions are met, it generates a `TradeSignal`.
4.  **Place Order**: The generated `TradeSignal` is passed to the existing `place_order` function in the `Execution Engine`. An order is created in the database.
5.  **Simulate Fill**: We will simulate a trade execution, creating a realistic `filled_price` that may differ slightly from the signal price.
6.  **Monitor Slippage**: The simulated fill information is passed to the existing `calculate_and_store_slippage` function.
7.  **Update & Alert**: The results are logged, the dashboard is updated with the new data, and any relevant alerts (e.g., high slippage) are triggered.

## 4. Implementation Steps

This phase will be broken down into the following concrete development tasks:

### Step 1: Create Mock Data Sources

-   **File**: `chunks/simulation/mock_data.py`
-   **Functions**:
    -   `generate_fear_greed_tick()`: Returns a random integer between 0 and 100.
    -   `generate_price_tick(current_price)`: Takes a price and returns a new price, simulating a random walk.
-   **Goal**: To have functions that can provide a continuous stream of simple, artificial market data.

### Step 2: Implement a Basic Sentiment Engine

-   **File**: `chunks/simulation/sentiment_engine.py`
-   **Function**: `determine_regime(fg_value)`
-   **Logic**: A simple function that takes the Fear & Greed value and returns a string representing the regime (e.g., if value < 25, return "Extreme Fear").
-   **Goal**: To translate raw data into a high-level market state.

### Step 3: Implement a Basic Strategy Engine

-   **File**: `chunks/simulation/strategy_engine.py`
-   **Function**: `generate_signal(regime, price_history)`
-   **Logic**: Implement a single, simple strategy. For example, a Trend Following strategy: "If the regime is 'Greed' and the price has increased for the last 3 ticks, generate a BUY signal."
-   **Goal**: To create a `TradeSignal` object based on the market state and price action.

### Step 4: Create the Master Simulation Script

-   **File**: `scripts/run_simulation.py`
-   **Logic**: This script will contain the main loop that orchestrates the entire simulation.
    -   Initialize mock data (e.g., starting price).
    -   Loop indefinitely (or for a set number of iterations).
    -   In each loop:
        1.  Call the functions from Steps 1, 2, and 3.
        2.  If a signal is generated, call the real `place_order` function.
        3.  Simulate the fill and call the real `calculate_and_store_slippage` function.
        4.  Print a clear log of the actions taken in the current tick.
        5.  Wait for a few seconds (`time.sleep()`) before the next tick.
-   **Goal**: To have a single, runnable script that demonstrates the entire system logic from end to end.

## 5. Acceptance Criteria

This simulation phase will be considered complete when:

-   The `run_simulation.py` script can be executed without errors.
-   The console output clearly shows the step-by-step decision-making process of the framework.
-   The Streamlit dashboard updates in near real-time, displaying the signals and orders generated by the simulation.
-   The `strategy_signals`, `orders`, and `slippage` tables in the database are populated with data from the simulation run.
